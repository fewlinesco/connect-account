/* tslint:disable */
/* eslint-disable */
/**
 * Connect Profile
 * The application stores user profile information, it is meant to be compliant to OpenID Connect specification
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * Identifier for the End-User at the Issuer.
     * @type {string}
     * @memberof InlineObject
     */
    sub?: string;
    /**
     * End-User\'s full name in displayable form including all name parts, possibly including titles and suffixes, ordered according to the End-User\'s preferences.
     * @type {string}
     * @memberof InlineObject
     */
    name?: string;
    /**
     * Surname(s) or last name(s) of the End-User. Note that in some cultures, people can have multiple family names or no family name; all can be present, with the names being separated by space characters.
     * @type {string}
     * @memberof InlineObject
     */
    family_name?: string;
    /**
     * Given name(s) or first name(s) of the End-User. Note that in some cultures, people can have multiple given names; all can be present, with the names being separated by space characters.
     * @type {string}
     * @memberof InlineObject
     */
    given_name?: string;
    /**
     * Middle name(s) of the End-User. Note that in some cultures, people can have multiple middle names; all can be present, with the names being separated by space characters. Also note that in some cultures, middle names are not used.
     * @type {string}
     * @memberof InlineObject
     */
    middle_name?: string;
    /**
     * Casual name of the End-User that may or may not be the same as the given_name. For instance, a nickname value of Mike might be returned alongside a given_name value of Michael.
     * @type {string}
     * @memberof InlineObject
     */
    nickname?: string;
    /**
     * Shorthand name by which the End-User wishes to be referred to by the Provider, such as janedoe or j.doe. This value MAY be any valid JSON string including special characters such as @, /, or whitespace. The Provider MUST NOT rely upon this value being unique.
     * @type {string}
     * @memberof InlineObject
     */
    preferred_username?: string;
    /**
     * URL of the End-User\'s profile page. The contents of this Web page SHOULD be about the End-User.
     * @type {string}
     * @memberof InlineObject
     */
    profile?: string;
    /**
     * URL of the End-User\'s profile picture. This URL MUST refer to an image file (for example, a PNG, JPEG, or GIF image file), rather than to a Web page containing an image. Note that this URL SHOULD specifically reference a profile photo of the End-User suitable for displaying when describing the End-User, rather than an arbitrary photo taken by the End-User.
     * @type {string}
     * @memberof InlineObject
     */
    picture?: string;
    /**
     * URL of the End-User\'s Web page or blog. This Web page SHOULD contain information published by the End-User or an organization that the End-User is affiliated with.
     * @type {string}
     * @memberof InlineObject
     */
    website?: string;
    /**
     * End-User\'s gender. Values defined by this specification are female and male. Other values MAY be used when neither of the defined values are applicable.
     * @type {string}
     * @memberof InlineObject
     */
    gender?: string;
    /**
     * End-User\'s birthday, represented as an ISO 8601:2004 [ISO8601‑2004] YYYY-MM-DD format. The year MAY be 0000, indicating that it is omitted. To represent only the year, YYYY format is allowed. Note that depending on the underlying platform\'s date related function, providing just year can result in varying month and day, so the implementers need to take this factor into account to correctly process the dates.
     * @type {string}
     * @memberof InlineObject
     */
    birthdate?: string;
    /**
     * String from zoneinfo [zoneinfo] time zone database representing the End-User\'s time zone. For example, Europe/Paris or America/Los_Angeles.
     * @type {string}
     * @memberof InlineObject
     */
    zoneinfo?: string;
    /**
     * End-User\'s locale.
     * @type {string}
     * @memberof InlineObject
     */
    locale?: string;
    /**
     * 
     * @type {UsersAddress}
     * @memberof InlineObject
     */
    address?: UsersAddress;
}
/**
 * 
 * @export
 * @interface InlineResponse401
 */
export interface InlineResponse401 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse401
     */
    error?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse4011
 */
export interface InlineResponse4011 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse4011
     */
    error?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse404
 */
export interface InlineResponse404 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse404
     */
    error?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse422
 */
export interface InlineResponse422 {
    /**
     * an english message describing the error
     * @type {string}
     * @memberof InlineResponse422
     */
    message?: InlineResponse422MessageEnum;
    /**
     * an object representing invalid fields
     * @type {object}
     * @memberof InlineResponse422
     */
    errors?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse422MessageEnum {
    ThereIsAlreadyAUserWithThisSubInDatabase = 'There is already a user with this sub in database',
    InvalidData = 'InvalidData'
}

/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * Identifier for the End-User at the Issuer.
     * @type {string}
     * @memberof UserResponse
     */
    sub?: string;
    /**
     * End-User\'s full name in displayable form including all name parts, possibly including titles and suffixes, ordered according to the End-User\'s preferences.
     * @type {string}
     * @memberof UserResponse
     */
    name?: string;
    /**
     * Surname(s) or last name(s) of the End-User. Note that in some cultures, people can have multiple family names or no family name; all can be present, with the names being separated by space characters.
     * @type {string}
     * @memberof UserResponse
     */
    family_name?: string;
    /**
     * Given name(s) or first name(s) of the End-User. Note that in some cultures, people can have multiple given names; all can be present, with the names being separated by space characters.
     * @type {string}
     * @memberof UserResponse
     */
    given_name?: string;
    /**
     * Middle name(s) of the End-User. Note that in some cultures, people can have multiple middle names; all can be present, with the names being separated by space characters. Also note that in some cultures, middle names are not used.
     * @type {string}
     * @memberof UserResponse
     */
    middle_name?: string;
    /**
     * Casual name of the End-User that may or may not be the same as the given_name. For instance, a nickname value of Mike might be returned alongside a given_name value of Michael.
     * @type {string}
     * @memberof UserResponse
     */
    nickname?: string;
    /**
     * Shorthand name by which the End-User wishes to be referred to by the Provider, such as janedoe or j.doe. This value MAY be any valid JSON string including special characters such as @, /, or whitespace. The Provider MUST NOT rely upon this value being unique.
     * @type {string}
     * @memberof UserResponse
     */
    preferred_username?: string;
    /**
     * URL of the End-User\'s profile page. The contents of this Web page SHOULD be about the End-User.
     * @type {string}
     * @memberof UserResponse
     */
    profile?: string;
    /**
     * URL of the End-User\'s profile picture. This URL MUST refer to an image file (for example, a PNG, JPEG, or GIF image file), rather than to a Web page containing an image. Note that this URL SHOULD specifically reference a profile photo of the End-User suitable for displaying when describing the End-User, rather than an arbitrary photo taken by the End-User.
     * @type {string}
     * @memberof UserResponse
     */
    picture?: string;
    /**
     * URL of the End-User\'s Web page or blog. This Web page SHOULD contain information published by the End-User or an organization that the End-User is affiliated with.
     * @type {string}
     * @memberof UserResponse
     */
    website?: string;
    /**
     * End-User\'s gender. Values defined by this specification are female and male. Other values MAY be used when neither of the defined values are applicable.
     * @type {string}
     * @memberof UserResponse
     */
    gender?: string;
    /**
     * End-User\'s birthday, represented as an ISO 8601:2004 [ISO8601‑2004] YYYY-MM-DD format. The year MAY be 0000, indicating that it is omitted. To represent only the year, YYYY format is allowed. Note that depending on the underlying platform\'s date related function, providing just year can result in varying month and day, so the implementers need to take this factor into account to correctly process the dates.
     * @type {string}
     * @memberof UserResponse
     */
    birthdate?: string;
    /**
     * String from zoneinfo [zoneinfo] time zone database representing the End-User\'s time zone. For example, Europe/Paris or America/Los_Angeles.
     * @type {string}
     * @memberof UserResponse
     */
    zoneinfo?: string;
    /**
     * End-User\'s locale.
     * @type {string}
     * @memberof UserResponse
     */
    locale?: string;
    /**
     * 
     * @type {UsersAddress}
     * @memberof UserResponse
     */
    address?: UsersAddress;
    /**
     * Time the End-User\'s information was last updated. Its value is a JSON number representing the number of seconds from 1970-01-01T0:0:0Z as measured in UTC until the date/time.
     * @type {number}
     * @memberof UserResponse
     */
    updated_at?: number;
}
/**
 * An object representing the User\'s address
 * @export
 * @interface UsersAddress
 */
export interface UsersAddress {
    /**
     * the formatted User\'s address
     * @type {string}
     * @memberof UsersAddress
     */
    formatted?: string;
}

/**
 * UsersProfileApi - axios parameter creator
 * @export
 */
export const UsersProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Register a user profile in the database.
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (inlineObject?: InlineObject, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject !== undefined ? inlineObject : {}) : (inlineObject || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a user based on the provided bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a user based on the provided sub
         * @param {string} sub the sub identifier of the requested User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBySub: async (sub: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sub' is not null or undefined
            if (sub === null || sub === undefined) {
                throw new RequiredError('sub','Required parameter sub was null or undefined when calling getUserBySub.');
            }
            const localVarPath = `/users/{sub}`
                .replace(`{${"sub"}}`, encodeURIComponent(String(sub)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a user based on the provided sub
         * @param {string} sub The sub identifier of the requested User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUser: async (sub: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sub' is not null or undefined
            if (sub === null || sub === undefined) {
                throw new RequiredError('sub','Required parameter sub was null or undefined when calling patchUser.');
            }
            const localVarPath = `/users/{sub}`
                .replace(`{${"sub"}}`, encodeURIComponent(String(sub)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersProfileApi - functional programming interface
 * @export
 */
export const UsersProfileApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Register a user profile in the database.
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(inlineObject?: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await UsersProfileApiAxiosParamCreator(configuration).createUser(inlineObject, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve a user based on the provided bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await UsersProfileApiAxiosParamCreator(configuration).getUser(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve a user based on the provided sub
         * @param {string} sub the sub identifier of the requested User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserBySub(sub: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await UsersProfileApiAxiosParamCreator(configuration).getUserBySub(sub, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update a user based on the provided sub
         * @param {string} sub The sub identifier of the requested User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchUser(sub: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await UsersProfileApiAxiosParamCreator(configuration).patchUser(sub, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UsersProfileApi - factory interface
 * @export
 */
export const UsersProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Register a user profile in the database.
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(inlineObject?: InlineObject, options?: any): AxiosPromise<UserResponse> {
            return UsersProfileApiFp(configuration).createUser(inlineObject, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a user based on the provided bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: any): AxiosPromise<UserResponse> {
            return UsersProfileApiFp(configuration).getUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a user based on the provided sub
         * @param {string} sub the sub identifier of the requested User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBySub(sub: string, options?: any): AxiosPromise<UserResponse> {
            return UsersProfileApiFp(configuration).getUserBySub(sub, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a user based on the provided sub
         * @param {string} sub The sub identifier of the requested User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUser(sub: string, options?: any): AxiosPromise<UserResponse> {
            return UsersProfileApiFp(configuration).patchUser(sub, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersProfileApi - object-oriented interface
 * @export
 * @class UsersProfileApi
 * @extends {BaseAPI}
 */
export class UsersProfileApi extends BaseAPI {
    /**
     * 
     * @summary Register a user profile in the database.
     * @param {InlineObject} [inlineObject] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersProfileApi
     */
    public createUser(inlineObject?: InlineObject, options?: any) {
        return UsersProfileApiFp(this.configuration).createUser(inlineObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a user based on the provided bearer token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersProfileApi
     */
    public getUser(options?: any) {
        return UsersProfileApiFp(this.configuration).getUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a user based on the provided sub
     * @param {string} sub the sub identifier of the requested User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersProfileApi
     */
    public getUserBySub(sub: string, options?: any) {
        return UsersProfileApiFp(this.configuration).getUserBySub(sub, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a user based on the provided sub
     * @param {string} sub The sub identifier of the requested User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersProfileApi
     */
    public patchUser(sub: string, options?: any) {
        return UsersProfileApiFp(this.configuration).patchUser(sub, options).then((request) => request(this.axios, this.basePath));
    }
}


