/* tslint:disable */
/* eslint-disable */
/**
 * Connect Profile
 * The application stores user profile information, it is meant to be compliant to OpenID Connect specification
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * An object representing the User\'s address
 * @export
 * @interface AddressData
 */
export interface AddressData {
    /**
     * Full street address of the End-User, which MAY include house number, street name, Post Office Box, and multi-line extended street address information. This field MAY contain multiple lines, separated by newlines. Newlines can be represented either as a carriage return/line feed pair (\"\\r\\n\") or as a single line feed character (\"\\n\")
     * @type {string}
     * @memberof AddressData
     */
    street_address?: string;
    /**
     * Optional additional composant for the street address, e.g: floor number, door number, ...
     * @type {string}
     * @memberof AddressData
     */
    street_address_2?: string;
    /**
     * City or locality of the End-User.
     * @type {string}
     * @memberof AddressData
     */
    locality: string;
    /**
     * State, province, prefecture, or region of the End-User.
     * @type {string}
     * @memberof AddressData
     */
    region?: string;
    /**
     * Zip code or postal code of the End-User.
     * @type {string}
     * @memberof AddressData
     */
    postal_code: string;
    /**
     * Country name of the End-User.
     * @type {string}
     * @memberof AddressData
     */
    country: string;
    /**
     * The type of the End-User\'s address, e.g: billing, delivery, ...
     * @type {string}
     * @memberof AddressData
     */
    kind?: string;
}
/**
 * 
 * @export
 * @interface AddressResponse
 */
export interface AddressResponse {
    /**
     * Full street address of the End-User, which MAY include house number, street name, Post Office Box, and multi-line extended street address information. This field MAY contain multiple lines, separated by newlines. Newlines can be represented either as a carriage return/line feed pair (\"\\r\\n\") or as a single line feed character (\"\\n\")
     * @type {string}
     * @memberof AddressResponse
     */
    street_address?: string;
    /**
     * Optional additional composant for the street address, e.g: floor number, door number, ...
     * @type {string}
     * @memberof AddressResponse
     */
    street_address_2?: string;
    /**
     * City or locality of the End-User.
     * @type {string}
     * @memberof AddressResponse
     */
    locality: string;
    /**
     * State, province, prefecture, or region of the End-User.
     * @type {string}
     * @memberof AddressResponse
     */
    region?: string;
    /**
     * Zip code or postal code of the End-User.
     * @type {string}
     * @memberof AddressResponse
     */
    postal_code: string;
    /**
     * Country name of the End-User.
     * @type {string}
     * @memberof AddressResponse
     */
    country: string;
    /**
     * The type of the End-User\'s address, e.g: billing, delivery, ...
     * @type {string}
     * @memberof AddressResponse
     */
    kind?: string;
    /**
     * Set to true means this is the user\'s primary address.
     * @type {boolean}
     * @memberof AddressResponse
     */
    primary?: boolean;
    /**
     * Identifier for the End-User at the Issuer.
     * @type {string}
     * @memberof AddressResponse
     */
    sub?: string;
    /**
     * Time the End-User\'s information was last updated. Its value is a JSON number representing the number of seconds from 1970-01-01T0:0:0Z as measured in UTC until the date/time.
     * @type {number}
     * @memberof AddressResponse
     */
    updated_at?: number;
}
/**
 * 
 * @export
 * @interface AddressResponseAllOf
 */
export interface AddressResponseAllOf {
    /**
     * Set to true means this is the user\'s primary address.
     * @type {boolean}
     * @memberof AddressResponseAllOf
     */
    primary?: boolean;
    /**
     * Identifier for the End-User at the Issuer.
     * @type {string}
     * @memberof AddressResponseAllOf
     */
    sub?: string;
    /**
     * Time the End-User\'s information was last updated. Its value is a JSON number representing the number of seconds from 1970-01-01T0:0:0Z as measured in UTC until the date/time.
     * @type {number}
     * @memberof AddressResponseAllOf
     */
    updated_at?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse401
 */
export interface InlineResponse401 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse401
     */
    error?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse4011
 */
export interface InlineResponse4011 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse4011
     */
    error?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse403
 */
export interface InlineResponse403 {
    /**
     * an english message describing the error
     * @type {string}
     * @memberof InlineResponse403
     */
    message?: InlineResponse403MessageEnum;
    /**
     * 
     * @type {InlineResponse403Errors}
     * @memberof InlineResponse403
     */
    errors?: InlineResponse403Errors;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse403MessageEnum {
    TheGivenScopesDontAllowYouToPerformThisAction = 'The given scopes don\'t allow you to perform this action'
}

/**
 * an object representing invalid scopes
 * @export
 * @interface InlineResponse403Errors
 */
export interface InlineResponse403Errors {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse403Errors
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse403Errors
     */
    openid?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse403Errors
     */
    profile?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse404
 */
export interface InlineResponse404 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse404
     */
    error?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse422
 */
export interface InlineResponse422 {
    /**
     * an english message describing the error
     * @type {string}
     * @memberof InlineResponse422
     */
    message?: InlineResponse422MessageEnum;
    /**
     * 
     * @type {InlineResponse422Errors}
     * @memberof InlineResponse422
     */
    errors?: InlineResponse422Errors;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse422MessageEnum {
    InvalidUserData = 'Invalid User data'
}

/**
 * an object representing invalid fields
 * @export
 * @interface InlineResponse422Errors
 */
export interface InlineResponse422Errors {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse422Errors
     */
    sub?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse422Errors
     */
    birthdate?: string;
}
/**
 * 
 * @export
 * @interface ProfileData
 */
export interface ProfileData {
    /**
     * End-User\'s full name in displayable form including all name parts, possibly including titles and suffixes, ordered according to the End-User\'s preferences.
     * @type {string}
     * @memberof ProfileData
     */
    name?: string;
    /**
     * Surname(s) or last name(s) of the End-User. Note that in some cultures, people can have multiple family names or no family name; all can be present, with the names being separated by space characters.
     * @type {string}
     * @memberof ProfileData
     */
    family_name?: string;
    /**
     * Given name(s) or first name(s) of the End-User. Note that in some cultures, people can have multiple given names; all can be present, with the names being separated by space characters.
     * @type {string}
     * @memberof ProfileData
     */
    given_name?: string;
    /**
     * Middle name(s) of the End-User. Note that in some cultures, people can have multiple middle names; all can be present, with the names being separated by space characters. Also note that in some cultures, middle names are not used.
     * @type {string}
     * @memberof ProfileData
     */
    middle_name?: string;
    /**
     * Casual name of the End-User that may or may not be the same as the given_name. For instance, a nickname value of Mike might be returned alongside a given_name value of Michael.
     * @type {string}
     * @memberof ProfileData
     */
    nickname?: string;
    /**
     * Shorthand name by which the End-User wishes to be referred to by the Provider, such as janedoe or j.doe. This value MAY be any valid JSON string including special characters such as @, /, or whitespace. The Provider MUST NOT rely upon this value being unique.
     * @type {string}
     * @memberof ProfileData
     */
    preferred_username?: string;
    /**
     * URL of the End-User\'s profile page. The contents of this Web page SHOULD be about the End-User.
     * @type {string}
     * @memberof ProfileData
     */
    profile?: string;
    /**
     * URL of the End-User\'s profile picture. This URL MUST refer to an image file (for example, a PNG, JPEG, or GIF image file), rather than to a Web page containing an image. Note that this URL SHOULD specifically reference a profile photo of the End-User suitable for displaying when describing the End-User, rather than an arbitrary photo taken by the End-User.
     * @type {string}
     * @memberof ProfileData
     */
    picture?: string;
    /**
     * URL of the End-User\'s Web page or blog. This Web page SHOULD contain information published by the End-User or an organization that the End-User is affiliated with.
     * @type {string}
     * @memberof ProfileData
     */
    website?: string;
    /**
     * End-User\'s gender. Values defined by this specification are female and male. Other values MAY be used when neither of the defined values are applicable.
     * @type {string}
     * @memberof ProfileData
     */
    gender?: string;
    /**
     * End-User\'s birthday, represented as an ISO 8601:2004 [ISO8601‑2004] YYYY-MM-DD format. The year MAY be 0000, indicating that it is omitted. To represent only the year, YYYY format is allowed. Note that depending on the underlying platform\'s date related function, providing just year can result in varying month and day, so the implementers need to take this factor into account to correctly process the dates.
     * @type {string}
     * @memberof ProfileData
     */
    birthdate?: string;
    /**
     * String from zoneinfo [zoneinfo] time zone database representing the End-User\'s time zone. For example, Europe/Paris or America/Los_Angeles.
     * @type {string}
     * @memberof ProfileData
     */
    zoneinfo?: string;
    /**
     * End-User\'s locale.
     * @type {string}
     * @memberof ProfileData
     */
    locale?: string;
}
/**
 * 
 * @export
 * @interface ProfileResponse
 */
export interface ProfileResponse {
    /**
     * End-User\'s full name in displayable form including all name parts, possibly including titles and suffixes, ordered according to the End-User\'s preferences.
     * @type {string}
     * @memberof ProfileResponse
     */
    name?: string;
    /**
     * Surname(s) or last name(s) of the End-User. Note that in some cultures, people can have multiple family names or no family name; all can be present, with the names being separated by space characters.
     * @type {string}
     * @memberof ProfileResponse
     */
    family_name?: string;
    /**
     * Given name(s) or first name(s) of the End-User. Note that in some cultures, people can have multiple given names; all can be present, with the names being separated by space characters.
     * @type {string}
     * @memberof ProfileResponse
     */
    given_name?: string;
    /**
     * Middle name(s) of the End-User. Note that in some cultures, people can have multiple middle names; all can be present, with the names being separated by space characters. Also note that in some cultures, middle names are not used.
     * @type {string}
     * @memberof ProfileResponse
     */
    middle_name?: string;
    /**
     * Casual name of the End-User that may or may not be the same as the given_name. For instance, a nickname value of Mike might be returned alongside a given_name value of Michael.
     * @type {string}
     * @memberof ProfileResponse
     */
    nickname?: string;
    /**
     * Shorthand name by which the End-User wishes to be referred to by the Provider, such as janedoe or j.doe. This value MAY be any valid JSON string including special characters such as @, /, or whitespace. The Provider MUST NOT rely upon this value being unique.
     * @type {string}
     * @memberof ProfileResponse
     */
    preferred_username?: string;
    /**
     * URL of the End-User\'s profile page. The contents of this Web page SHOULD be about the End-User.
     * @type {string}
     * @memberof ProfileResponse
     */
    profile?: string;
    /**
     * URL of the End-User\'s profile picture. This URL MUST refer to an image file (for example, a PNG, JPEG, or GIF image file), rather than to a Web page containing an image. Note that this URL SHOULD specifically reference a profile photo of the End-User suitable for displaying when describing the End-User, rather than an arbitrary photo taken by the End-User.
     * @type {string}
     * @memberof ProfileResponse
     */
    picture?: string;
    /**
     * URL of the End-User\'s Web page or blog. This Web page SHOULD contain information published by the End-User or an organization that the End-User is affiliated with.
     * @type {string}
     * @memberof ProfileResponse
     */
    website?: string;
    /**
     * End-User\'s gender. Values defined by this specification are female and male. Other values MAY be used when neither of the defined values are applicable.
     * @type {string}
     * @memberof ProfileResponse
     */
    gender?: string;
    /**
     * End-User\'s birthday, represented as an ISO 8601:2004 [ISO8601‑2004] YYYY-MM-DD format. The year MAY be 0000, indicating that it is omitted. To represent only the year, YYYY format is allowed. Note that depending on the underlying platform\'s date related function, providing just year can result in varying month and day, so the implementers need to take this factor into account to correctly process the dates.
     * @type {string}
     * @memberof ProfileResponse
     */
    birthdate?: string;
    /**
     * String from zoneinfo [zoneinfo] time zone database representing the End-User\'s time zone. For example, Europe/Paris or America/Los_Angeles.
     * @type {string}
     * @memberof ProfileResponse
     */
    zoneinfo?: string;
    /**
     * End-User\'s locale.
     * @type {string}
     * @memberof ProfileResponse
     */
    locale?: string;
    /**
     * Identifier for the End-User at the Issuer.
     * @type {string}
     * @memberof ProfileResponse
     */
    sub?: string;
    /**
     * Time the End-User\'s information was last updated. Its value is a JSON number representing the number of seconds from 1970-01-01T0:0:0Z as measured in UTC until the date/time.
     * @type {number}
     * @memberof ProfileResponse
     */
    updated_at?: number;
}
/**
 * 
 * @export
 * @interface ProfileResponseAllOf
 */
export interface ProfileResponseAllOf {
    /**
     * Identifier for the End-User at the Issuer.
     * @type {string}
     * @memberof ProfileResponseAllOf
     */
    sub?: string;
    /**
     * Time the End-User\'s information was last updated. Its value is a JSON number representing the number of seconds from 1970-01-01T0:0:0Z as measured in UTC until the date/time.
     * @type {number}
     * @memberof ProfileResponseAllOf
     */
    updated_at?: number;
}
/**
 * 
 * @export
 * @interface UserData
 */
export interface UserData {
    /**
     * End-User\'s full name in displayable form including all name parts, possibly including titles and suffixes, ordered according to the End-User\'s preferences.
     * @type {string}
     * @memberof UserData
     */
    name?: string;
    /**
     * Surname(s) or last name(s) of the End-User. Note that in some cultures, people can have multiple family names or no family name; all can be present, with the names being separated by space characters.
     * @type {string}
     * @memberof UserData
     */
    family_name?: string;
    /**
     * Given name(s) or first name(s) of the End-User. Note that in some cultures, people can have multiple given names; all can be present, with the names being separated by space characters.
     * @type {string}
     * @memberof UserData
     */
    given_name?: string;
    /**
     * Middle name(s) of the End-User. Note that in some cultures, people can have multiple middle names; all can be present, with the names being separated by space characters. Also note that in some cultures, middle names are not used.
     * @type {string}
     * @memberof UserData
     */
    middle_name?: string;
    /**
     * Casual name of the End-User that may or may not be the same as the given_name. For instance, a nickname value of Mike might be returned alongside a given_name value of Michael.
     * @type {string}
     * @memberof UserData
     */
    nickname?: string;
    /**
     * Shorthand name by which the End-User wishes to be referred to by the Provider, such as janedoe or j.doe. This value MAY be any valid JSON string including special characters such as @, /, or whitespace. The Provider MUST NOT rely upon this value being unique.
     * @type {string}
     * @memberof UserData
     */
    preferred_username?: string;
    /**
     * URL of the End-User\'s profile page. The contents of this Web page SHOULD be about the End-User.
     * @type {string}
     * @memberof UserData
     */
    profile?: string;
    /**
     * URL of the End-User\'s profile picture. This URL MUST refer to an image file (for example, a PNG, JPEG, or GIF image file), rather than to a Web page containing an image. Note that this URL SHOULD specifically reference a profile photo of the End-User suitable for displaying when describing the End-User, rather than an arbitrary photo taken by the End-User.
     * @type {string}
     * @memberof UserData
     */
    picture?: string;
    /**
     * URL of the End-User\'s Web page or blog. This Web page SHOULD contain information published by the End-User or an organization that the End-User is affiliated with.
     * @type {string}
     * @memberof UserData
     */
    website?: string;
    /**
     * End-User\'s gender. Values defined by this specification are female and male. Other values MAY be used when neither of the defined values are applicable.
     * @type {string}
     * @memberof UserData
     */
    gender?: string;
    /**
     * End-User\'s birthday, represented as an ISO 8601:2004 [ISO8601‑2004] YYYY-MM-DD format. The year MAY be 0000, indicating that it is omitted. To represent only the year, YYYY format is allowed. Note that depending on the underlying platform\'s date related function, providing just year can result in varying month and day, so the implementers need to take this factor into account to correctly process the dates.
     * @type {string}
     * @memberof UserData
     */
    birthdate?: string;
    /**
     * String from zoneinfo [zoneinfo] time zone database representing the End-User\'s time zone. For example, Europe/Paris or America/Los_Angeles.
     * @type {string}
     * @memberof UserData
     */
    zoneinfo?: string;
    /**
     * End-User\'s locale.
     * @type {string}
     * @memberof UserData
     */
    locale?: string;
    /**
     * 
     * @type {UserDataAddress}
     * @memberof UserData
     */
    address?: UserDataAddress;
}
/**
 * An object representing the User\'s address
 * @export
 * @interface UserDataAddress
 */
export interface UserDataAddress {
    /**
     * Full street address of the End-User, which MAY include house number, street name, Post Office Box, and multi-line extended street address information. This field MAY contain multiple lines, separated by newlines. Newlines can be represented either as a carriage return/line feed pair (\"\\r\\n\") or as a single line feed character (\"\\n\").
     * @type {string}
     * @memberof UserDataAddress
     */
    street_address?: string;
    /**
     * City or locality of the End-User.
     * @type {string}
     * @memberof UserDataAddress
     */
    locality?: string;
    /**
     * State, province, prefecture, or region of the End-User.
     * @type {string}
     * @memberof UserDataAddress
     */
    region?: string;
    /**
     * Zip code or postal code of the End-User.
     * @type {string}
     * @memberof UserDataAddress
     */
    postal_code?: string;
    /**
     * Country name of the End-User.
     * @type {string}
     * @memberof UserDataAddress
     */
    country?: string;
}
/**
 * 
 * @export
 * @interface UserPayload
 */
export interface UserPayload {
    /**
     * End-User\'s full name in displayable form including all name parts, possibly including titles and suffixes, ordered according to the End-User\'s preferences.
     * @type {string}
     * @memberof UserPayload
     */
    name?: string;
    /**
     * Surname(s) or last name(s) of the End-User. Note that in some cultures, people can have multiple family names or no family name; all can be present, with the names being separated by space characters.
     * @type {string}
     * @memberof UserPayload
     */
    family_name?: string;
    /**
     * Given name(s) or first name(s) of the End-User. Note that in some cultures, people can have multiple given names; all can be present, with the names being separated by space characters.
     * @type {string}
     * @memberof UserPayload
     */
    given_name?: string;
    /**
     * Middle name(s) of the End-User. Note that in some cultures, people can have multiple middle names; all can be present, with the names being separated by space characters. Also note that in some cultures, middle names are not used.
     * @type {string}
     * @memberof UserPayload
     */
    middle_name?: string;
    /**
     * Casual name of the End-User that may or may not be the same as the given_name. For instance, a nickname value of Mike might be returned alongside a given_name value of Michael.
     * @type {string}
     * @memberof UserPayload
     */
    nickname?: string;
    /**
     * Shorthand name by which the End-User wishes to be referred to by the Provider, such as janedoe or j.doe. This value MAY be any valid JSON string including special characters such as @, /, or whitespace. The Provider MUST NOT rely upon this value being unique.
     * @type {string}
     * @memberof UserPayload
     */
    preferred_username?: string;
    /**
     * URL of the End-User\'s profile page. The contents of this Web page SHOULD be about the End-User.
     * @type {string}
     * @memberof UserPayload
     */
    profile?: string;
    /**
     * URL of the End-User\'s profile picture. This URL MUST refer to an image file (for example, a PNG, JPEG, or GIF image file), rather than to a Web page containing an image. Note that this URL SHOULD specifically reference a profile photo of the End-User suitable for displaying when describing the End-User, rather than an arbitrary photo taken by the End-User.
     * @type {string}
     * @memberof UserPayload
     */
    picture?: string;
    /**
     * URL of the End-User\'s Web page or blog. This Web page SHOULD contain information published by the End-User or an organization that the End-User is affiliated with.
     * @type {string}
     * @memberof UserPayload
     */
    website?: string;
    /**
     * End-User\'s gender. Values defined by this specification are female and male. Other values MAY be used when neither of the defined values are applicable.
     * @type {string}
     * @memberof UserPayload
     */
    gender?: string;
    /**
     * End-User\'s birthday, represented as an ISO 8601:2004 [ISO8601‑2004] YYYY-MM-DD format. The year MAY be 0000, indicating that it is omitted. To represent only the year, YYYY format is allowed. Note that depending on the underlying platform\'s date related function, providing just year can result in varying month and day, so the implementers need to take this factor into account to correctly process the dates.
     * @type {string}
     * @memberof UserPayload
     */
    birthdate?: string;
    /**
     * String from zoneinfo [zoneinfo] time zone database representing the End-User\'s time zone. For example, Europe/Paris or America/Los_Angeles.
     * @type {string}
     * @memberof UserPayload
     */
    zoneinfo?: string;
    /**
     * End-User\'s locale.
     * @type {string}
     * @memberof UserPayload
     */
    locale?: string;
    /**
     * 
     * @type {UserDataAddress}
     * @memberof UserPayload
     */
    address?: UserDataAddress;
    /**
     * Identifier for the End-User at the Issuer.
     * @type {string}
     * @memberof UserPayload
     */
    sub: string;
}
/**
 * 
 * @export
 * @interface UserPayloadAllOf
 */
export interface UserPayloadAllOf {
    /**
     * Identifier for the End-User at the Issuer.
     * @type {string}
     * @memberof UserPayloadAllOf
     */
    sub?: string;
}
/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * End-User\'s full name in displayable form including all name parts, possibly including titles and suffixes, ordered according to the End-User\'s preferences.
     * @type {string}
     * @memberof UserResponse
     */
    name?: string;
    /**
     * Surname(s) or last name(s) of the End-User. Note that in some cultures, people can have multiple family names or no family name; all can be present, with the names being separated by space characters.
     * @type {string}
     * @memberof UserResponse
     */
    family_name?: string;
    /**
     * Given name(s) or first name(s) of the End-User. Note that in some cultures, people can have multiple given names; all can be present, with the names being separated by space characters.
     * @type {string}
     * @memberof UserResponse
     */
    given_name?: string;
    /**
     * Middle name(s) of the End-User. Note that in some cultures, people can have multiple middle names; all can be present, with the names being separated by space characters. Also note that in some cultures, middle names are not used.
     * @type {string}
     * @memberof UserResponse
     */
    middle_name?: string;
    /**
     * Casual name of the End-User that may or may not be the same as the given_name. For instance, a nickname value of Mike might be returned alongside a given_name value of Michael.
     * @type {string}
     * @memberof UserResponse
     */
    nickname?: string;
    /**
     * Shorthand name by which the End-User wishes to be referred to by the Provider, such as janedoe or j.doe. This value MAY be any valid JSON string including special characters such as @, /, or whitespace. The Provider MUST NOT rely upon this value being unique.
     * @type {string}
     * @memberof UserResponse
     */
    preferred_username?: string;
    /**
     * URL of the End-User\'s profile page. The contents of this Web page SHOULD be about the End-User.
     * @type {string}
     * @memberof UserResponse
     */
    profile?: string;
    /**
     * URL of the End-User\'s profile picture. This URL MUST refer to an image file (for example, a PNG, JPEG, or GIF image file), rather than to a Web page containing an image. Note that this URL SHOULD specifically reference a profile photo of the End-User suitable for displaying when describing the End-User, rather than an arbitrary photo taken by the End-User.
     * @type {string}
     * @memberof UserResponse
     */
    picture?: string;
    /**
     * URL of the End-User\'s Web page or blog. This Web page SHOULD contain information published by the End-User or an organization that the End-User is affiliated with.
     * @type {string}
     * @memberof UserResponse
     */
    website?: string;
    /**
     * End-User\'s gender. Values defined by this specification are female and male. Other values MAY be used when neither of the defined values are applicable.
     * @type {string}
     * @memberof UserResponse
     */
    gender?: string;
    /**
     * End-User\'s birthday, represented as an ISO 8601:2004 [ISO8601‑2004] YYYY-MM-DD format. The year MAY be 0000, indicating that it is omitted. To represent only the year, YYYY format is allowed. Note that depending on the underlying platform\'s date related function, providing just year can result in varying month and day, so the implementers need to take this factor into account to correctly process the dates.
     * @type {string}
     * @memberof UserResponse
     */
    birthdate?: string;
    /**
     * String from zoneinfo [zoneinfo] time zone database representing the End-User\'s time zone. For example, Europe/Paris or America/Los_Angeles.
     * @type {string}
     * @memberof UserResponse
     */
    zoneinfo?: string;
    /**
     * End-User\'s locale.
     * @type {string}
     * @memberof UserResponse
     */
    locale?: string;
    /**
     * 
     * @type {UserDataAddress}
     * @memberof UserResponse
     */
    address?: UserDataAddress;
    /**
     * Identifier for the End-User at the Issuer.
     * @type {string}
     * @memberof UserResponse
     */
    sub: string;
    /**
     * Time the End-User\'s information was last updated. Its value is a JSON number representing the number of seconds from 1970-01-01T0:0:0Z as measured in UTC until the date/time.
     * @type {number}
     * @memberof UserResponse
     */
    updated_at?: number;
}
/**
 * 
 * @export
 * @interface UserResponseAllOf
 */
export interface UserResponseAllOf {
    /**
     * Time the End-User\'s information was last updated. Its value is a JSON number representing the number of seconds from 1970-01-01T0:0:0Z as measured in UTC until the date/time.
     * @type {number}
     * @memberof UserResponseAllOf
     */
    updated_at?: number;
}

/**
 * ConnectProfileApi - axios parameter creator
 * @export
 */
export const ConnectProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Register user\'s address based on the provided bearer token
         * @param {AddressData} addressData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAddress: async (addressData: AddressData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressData' is not null or undefined
            assertParamExists('createAddress', 'addressData', addressData)
            const localVarPath = `/users/me/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a user\'s profile based on the provided bearer token
         * @param {ProfileData} profileData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfile: async (profileData: ProfileData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileData' is not null or undefined
            assertParamExists('createProfile', 'profileData', profileData)
            const localVarPath = `/users/me/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profileData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve all user\'s addresses based on the provided bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddresses: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a user based on the provided bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a user\'s profile based on the provided bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a user based on the provided bearer token
         * @param {UserData} userData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMe: async (userData: UserData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userData' is not null or undefined
            assertParamExists('patchMe', 'userData', userData)
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a user\'s profile based on the provided bearer token
         * @param {ProfileData} profileData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProfile: async (profileData: ProfileData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileData' is not null or undefined
            assertParamExists('patchProfile', 'profileData', profileData)
            const localVarPath = `/users/me/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profileData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectProfileApi - functional programming interface
 * @export
 */
export const ConnectProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Register user\'s address based on the provided bearer token
         * @param {AddressData} addressData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAddress(addressData: AddressData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAddress(addressData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a user\'s profile based on the provided bearer token
         * @param {ProfileData} profileData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProfile(profileData: ProfileData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProfile(profileData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve all user\'s addresses based on the provided bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddresses(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AddressResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddresses(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a user based on the provided bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMe(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMe(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a user\'s profile based on the provided bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfile(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfile(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a user based on the provided bearer token
         * @param {UserData} userData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMe(userData: UserData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchMe(userData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a user\'s profile based on the provided bearer token
         * @param {ProfileData} profileData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchProfile(profileData: ProfileData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchProfile(profileData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConnectProfileApi - factory interface
 * @export
 */
export const ConnectProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectProfileApiFp(configuration)
    return {
        /**
         * 
         * @summary Register user\'s address based on the provided bearer token
         * @param {AddressData} addressData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAddress(addressData: AddressData, options?: any): AxiosPromise<AddressResponse> {
            return localVarFp.createAddress(addressData, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a user\'s profile based on the provided bearer token
         * @param {ProfileData} profileData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfile(profileData: ProfileData, options?: any): AxiosPromise<ProfileResponse> {
            return localVarFp.createProfile(profileData, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve all user\'s addresses based on the provided bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddresses(options?: any): AxiosPromise<Array<AddressResponse>> {
            return localVarFp.getAddresses(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a user based on the provided bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options?: any): AxiosPromise<UserResponse> {
            return localVarFp.getMe(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a user\'s profile based on the provided bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile(options?: any): AxiosPromise<ProfileResponse> {
            return localVarFp.getProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a user based on the provided bearer token
         * @param {UserData} userData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMe(userData: UserData, options?: any): AxiosPromise<UserResponse> {
            return localVarFp.patchMe(userData, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a user\'s profile based on the provided bearer token
         * @param {ProfileData} profileData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProfile(profileData: ProfileData, options?: any): AxiosPromise<ProfileResponse> {
            return localVarFp.patchProfile(profileData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConnectProfileApi - object-oriented interface
 * @export
 * @class ConnectProfileApi
 * @extends {BaseAPI}
 */
export class ConnectProfileApi extends BaseAPI {
    /**
     * 
     * @summary Register user\'s address based on the provided bearer token
     * @param {AddressData} addressData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectProfileApi
     */
    public createAddress(addressData: AddressData, options?: any) {
        return ConnectProfileApiFp(this.configuration).createAddress(addressData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a user\'s profile based on the provided bearer token
     * @param {ProfileData} profileData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectProfileApi
     */
    public createProfile(profileData: ProfileData, options?: any) {
        return ConnectProfileApiFp(this.configuration).createProfile(profileData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve all user\'s addresses based on the provided bearer token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectProfileApi
     */
    public getAddresses(options?: any) {
        return ConnectProfileApiFp(this.configuration).getAddresses(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a user based on the provided bearer token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectProfileApi
     */
    public getMe(options?: any) {
        return ConnectProfileApiFp(this.configuration).getMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a user\'s profile based on the provided bearer token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectProfileApi
     */
    public getProfile(options?: any) {
        return ConnectProfileApiFp(this.configuration).getProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a user based on the provided bearer token
     * @param {UserData} userData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectProfileApi
     */
    public patchMe(userData: UserData, options?: any) {
        return ConnectProfileApiFp(this.configuration).patchMe(userData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a user\'s profile based on the provided bearer token
     * @param {ProfileData} profileData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectProfileApi
     */
    public patchProfile(profileData: ProfileData, options?: any) {
        return ConnectProfileApiFp(this.configuration).patchProfile(profileData, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConnectProfileAdminApi - axios parameter creator
 * @export
 */
export const ConnectProfileAdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Register a user profile in the database.
         * @param {UserPayload} userPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (userPayload: UserPayload, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userPayload' is not null or undefined
            assertParamExists('createUser', 'userPayload', userPayload)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a user based on the provided sub
         * @param {string} sub the sub identifier of the requested User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (sub: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sub' is not null or undefined
            assertParamExists('getUser', 'sub', sub)
            const localVarPath = `/users/{sub}`
                .replace(`{${"sub"}}`, encodeURIComponent(String(sub)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a user based on the provided sub
         * @param {string} sub The sub identifier of the requested User
         * @param {UserData} userData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUser: async (sub: string, userData: UserData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sub' is not null or undefined
            assertParamExists('patchUser', 'sub', sub)
            // verify required parameter 'userData' is not null or undefined
            assertParamExists('patchUser', 'userData', userData)
            const localVarPath = `/users/{sub}`
                .replace(`{${"sub"}}`, encodeURIComponent(String(sub)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectProfileAdminApi - functional programming interface
 * @export
 */
export const ConnectProfileAdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectProfileAdminApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Register a user profile in the database.
         * @param {UserPayload} userPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(userPayload: UserPayload, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(userPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a user based on the provided sub
         * @param {string} sub the sub identifier of the requested User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(sub: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(sub, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a user based on the provided sub
         * @param {string} sub The sub identifier of the requested User
         * @param {UserData} userData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchUser(sub: string, userData: UserData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchUser(sub, userData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConnectProfileAdminApi - factory interface
 * @export
 */
export const ConnectProfileAdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectProfileAdminApiFp(configuration)
    return {
        /**
         * 
         * @summary Register a user profile in the database.
         * @param {UserPayload} userPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(userPayload: UserPayload, options?: any): AxiosPromise<UserResponse> {
            return localVarFp.createUser(userPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a user based on the provided sub
         * @param {string} sub the sub identifier of the requested User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(sub: string, options?: any): AxiosPromise<UserResponse> {
            return localVarFp.getUser(sub, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a user based on the provided sub
         * @param {string} sub The sub identifier of the requested User
         * @param {UserData} userData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUser(sub: string, userData: UserData, options?: any): AxiosPromise<UserResponse> {
            return localVarFp.patchUser(sub, userData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConnectProfileAdminApi - object-oriented interface
 * @export
 * @class ConnectProfileAdminApi
 * @extends {BaseAPI}
 */
export class ConnectProfileAdminApi extends BaseAPI {
    /**
     * 
     * @summary Register a user profile in the database.
     * @param {UserPayload} userPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectProfileAdminApi
     */
    public createUser(userPayload: UserPayload, options?: any) {
        return ConnectProfileAdminApiFp(this.configuration).createUser(userPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a user based on the provided sub
     * @param {string} sub the sub identifier of the requested User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectProfileAdminApi
     */
    public getUser(sub: string, options?: any) {
        return ConnectProfileAdminApiFp(this.configuration).getUser(sub, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a user based on the provided sub
     * @param {string} sub The sub identifier of the requested User
     * @param {UserData} userData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectProfileAdminApi
     */
    public patchUser(sub: string, userData: UserData, options?: any) {
        return ConnectProfileAdminApiFp(this.configuration).patchUser(sub, userData, options).then((request) => request(this.axios, this.basePath));
    }
}


