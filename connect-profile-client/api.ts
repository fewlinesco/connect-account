/* tslint:disable */
/* eslint-disable */
/**
 * Connect Profile
 * The application stores user profile information, it is meant to be compliant with OpenID Connect specification
 *
 * The version of the OpenAPI document: 0.2.0
 * Contact: info@fewlines.co
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * An object representing the User\'s address
 * @export
 * @interface AddressData
 */
export interface AddressData {
    /**
     * Full street address of the End-User, which MAY include house number, street name, Post Office Box, and multi-line extended street address information. This field MAY contain multiple lines, separated by newlines. Newlines can be represented either as a carriage return/line feed pair (\"\\r\\n\") or as a single line feed character (\"\\n\")
     * @type {string}
     * @memberof AddressData
     */
    street_address?: string;
    /**
     * Optional additional component for the street address, e.g: floor number, door number, ...
     * @type {string}
     * @memberof AddressData
     */
    street_address_2?: string;
    /**
     * City or locality of the End-User.
     * @type {string}
     * @memberof AddressData
     */
    locality?: string;
    /**
     * State, province, prefecture, or region of the End-User.
     * @type {string}
     * @memberof AddressData
     */
    region?: string;
    /**
     * Zip code or postal code of the End-User.
     * @type {string}
     * @memberof AddressData
     */
    postal_code?: string;
    /**
     * Country name of the End-User.
     * @type {string}
     * @memberof AddressData
     */
    country?: string;
    /**
     * The type of the End-User\'s address, e.g: billing, delivery, ...
     * @type {string}
     * @memberof AddressData
     */
    kind?: string;
}
/**
 * 
 * @export
 * @interface AddressPayload
 */
export interface AddressPayload {
    /**
     * Full street address of the End-User, which MAY include house number, street name, Post Office Box, and multi-line extended street address information. This field MAY contain multiple lines, separated by newlines. Newlines can be represented either as a carriage return/line feed pair (\"\\r\\n\") or as a single line feed character (\"\\n\")
     * @type {string}
     * @memberof AddressPayload
     */
    street_address?: string;
    /**
     * Optional additional component for the street address, e.g: floor number, door number, ...
     * @type {string}
     * @memberof AddressPayload
     */
    street_address_2?: string;
    /**
     * City or locality of the End-User.
     * @type {string}
     * @memberof AddressPayload
     */
    locality: string;
    /**
     * State, province, prefecture, or region of the End-User.
     * @type {string}
     * @memberof AddressPayload
     */
    region?: string;
    /**
     * Zip code or postal code of the End-User.
     * @type {string}
     * @memberof AddressPayload
     */
    postal_code: string;
    /**
     * Country name of the End-User.
     * @type {string}
     * @memberof AddressPayload
     */
    country: string;
    /**
     * The type of the End-User\'s address, e.g: billing, delivery, ...
     * @type {string}
     * @memberof AddressPayload
     */
    kind?: string;
}
/**
 * 
 * @export
 * @interface AddressResponse
 */
export interface AddressResponse {
    /**
     * Full street address of the End-User, which MAY include house number, street name, Post Office Box, and multi-line extended street address information. This field MAY contain multiple lines, separated by newlines. Newlines can be represented either as a carriage return/line feed pair (\"\\r\\n\") or as a single line feed character (\"\\n\")
     * @type {string}
     * @memberof AddressResponse
     */
    street_address?: string;
    /**
     * Optional additional component for the street address, e.g: floor number, door number, ...
     * @type {string}
     * @memberof AddressResponse
     */
    street_address_2?: string;
    /**
     * City or locality of the End-User.
     * @type {string}
     * @memberof AddressResponse
     */
    locality?: string;
    /**
     * State, province, prefecture, or region of the End-User.
     * @type {string}
     * @memberof AddressResponse
     */
    region?: string;
    /**
     * Zip code or postal code of the End-User.
     * @type {string}
     * @memberof AddressResponse
     */
    postal_code?: string;
    /**
     * Country name of the End-User.
     * @type {string}
     * @memberof AddressResponse
     */
    country?: string;
    /**
     * The type of the End-User\'s address, e.g: billing, delivery, ...
     * @type {string}
     * @memberof AddressResponse
     */
    kind?: string;
    /**
     * Set to true means this is the user\'s primary address.
     * @type {boolean}
     * @memberof AddressResponse
     */
    primary?: boolean;
    /**
     * Time the End-User\'s information was last updated. Its value is a JSON number representing the number of seconds from 1970-01-01T0:0:0Z as measured in UTC until the date/time.
     * @type {number}
     * @memberof AddressResponse
     */
    updated_at?: number;
    /**
     * Address\'s unique identifier.
     * @type {string}
     * @memberof AddressResponse
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface AddressResponseAllOf
 */
export interface AddressResponseAllOf {
    /**
     * Set to true means this is the user\'s primary address.
     * @type {boolean}
     * @memberof AddressResponseAllOf
     */
    primary?: boolean;
    /**
     * Time the End-User\'s information was last updated. Its value is a JSON number representing the number of seconds from 1970-01-01T0:0:0Z as measured in UTC until the date/time.
     * @type {number}
     * @memberof AddressResponseAllOf
     */
    updated_at?: number;
    /**
     * Address\'s unique identifier.
     * @type {string}
     * @memberof AddressResponseAllOf
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse401
 */
export interface InlineResponse401 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse401
     */
    error?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse403
 */
export interface InlineResponse403 {
    /**
     * an english message describing the error
     * @type {string}
     * @memberof InlineResponse403
     */
    message?: InlineResponse403MessageEnum;
    /**
     * 
     * @type {InlineResponse403Errors}
     * @memberof InlineResponse403
     */
    errors?: InlineResponse403Errors;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse403MessageEnum {
    TheGivenScopesDontAllowYouToPerformThisAction = 'The given scopes don\'t allow you to perform this action'
}

/**
 * an object representing invalid scopes
 * @export
 * @interface InlineResponse403Errors
 */
export interface InlineResponse403Errors {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse403Errors
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse403Errors
     */
    openid?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse403Errors
     */
    profile?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse404
 */
export interface InlineResponse404 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse404
     */
    error?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse4041
 */
export interface InlineResponse4041 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse4041
     */
    error?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse422
 */
export interface InlineResponse422 {
    /**
     * an english message describing the error
     * @type {string}
     * @memberof InlineResponse422
     */
    message?: InlineResponse422MessageEnum;
    /**
     * 
     * @type {InlineResponse422Errors}
     * @memberof InlineResponse422
     */
    errors?: InlineResponse422Errors;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse422MessageEnum {
    InvalidUserData = 'Invalid User data'
}

/**
 * an object representing invalid fields
 * @export
 * @interface InlineResponse422Errors
 */
export interface InlineResponse422Errors {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse422Errors
     */
    sub?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse422Errors
     */
    birthdate?: string;
}
/**
 * 
 * @export
 * @interface ProfileData
 */
export interface ProfileData {
    /**
     * End-User\'s full name in displayable form including all name parts, possibly including titles and suffixes, ordered according to the End-User\'s preferences.
     * @type {string}
     * @memberof ProfileData
     */
    name?: string;
    /**
     * Surname(s) or last name(s) of the End-User. Note that in some cultures, people can have multiple family names or no family name; all can be present, with the names being separated by space characters.
     * @type {string}
     * @memberof ProfileData
     */
    family_name?: string;
    /**
     * Given name(s) or first name(s) of the End-User. Note that in some cultures, people can have multiple given names; all can be present, with the names being separated by space characters.
     * @type {string}
     * @memberof ProfileData
     */
    given_name?: string;
    /**
     * Middle name(s) of the End-User. Note that in some cultures, people can have multiple middle names; all can be present, with the names being separated by space characters. Also note that in some cultures, middle names are not used.
     * @type {string}
     * @memberof ProfileData
     */
    middle_name?: string;
    /**
     * Casual name of the End-User that may or may not be the same as the given_name. For instance, a nickname value of Mike might be returned alongside a given_name value of Michael.
     * @type {string}
     * @memberof ProfileData
     */
    nickname?: string;
    /**
     * Shorthand name by which the End-User wishes to be referred to by the Provider, such as janedoe or j.doe. This value MAY be any valid JSON string including special characters such as @, /, or whitespace. The Provider MUST NOT rely upon this value being unique.
     * @type {string}
     * @memberof ProfileData
     */
    preferred_username?: string;
    /**
     * URL of the End-User\'s profile page. The contents of this Web page SHOULD be about the End-User.
     * @type {string}
     * @memberof ProfileData
     */
    profile?: string;
    /**
     * URL of the End-User\'s profile picture. This URL MUST refer to an image file (for example, a PNG, JPEG, or GIF image file), rather than to a Web page containing an image. Note that this URL SHOULD specifically reference a profile photo of the End-User suitable for displaying when describing the End-User, rather than an arbitrary photo taken by the End-User.
     * @type {string}
     * @memberof ProfileData
     */
    picture?: string;
    /**
     * URL of the End-User\'s Web page or blog. This Web page SHOULD contain information published by the End-User or an organization that the End-User is affiliated with.
     * @type {string}
     * @memberof ProfileData
     */
    website?: string;
    /**
     * End-User\'s gender. Values defined by this specification are female and male. Other values MAY be used when neither of the defined values are applicable.
     * @type {string}
     * @memberof ProfileData
     */
    gender?: string;
    /**
     * End-User\'s birthday, represented as an ISO 8601:2004 [ISO8601‑2004] YYYY-MM-DD format. The year MAY be 0000, indicating that it is omitted. To represent only the year, YYYY format is allowed. Note that depending on the underlying platform\'s date related function, providing just year can result in varying month and day, so the implementers need to take this factor into account to correctly process the dates.
     * @type {string}
     * @memberof ProfileData
     */
    birthdate?: string;
    /**
     * String from zoneinfo [zoneinfo] time zone database representing the End-User\'s time zone. For example, Europe/Paris or America/Los_Angeles.
     * @type {string}
     * @memberof ProfileData
     */
    zoneinfo?: string;
    /**
     * End-User\'s locale.
     * @type {string}
     * @memberof ProfileData
     */
    locale?: string;
}
/**
 * 
 * @export
 * @interface ProfileResponse
 */
export interface ProfileResponse {
    /**
     * End-User\'s full name in displayable form including all name parts, possibly including titles and suffixes, ordered according to the End-User\'s preferences.
     * @type {string}
     * @memberof ProfileResponse
     */
    name?: string;
    /**
     * Surname(s) or last name(s) of the End-User. Note that in some cultures, people can have multiple family names or no family name; all can be present, with the names being separated by space characters.
     * @type {string}
     * @memberof ProfileResponse
     */
    family_name?: string;
    /**
     * Given name(s) or first name(s) of the End-User. Note that in some cultures, people can have multiple given names; all can be present, with the names being separated by space characters.
     * @type {string}
     * @memberof ProfileResponse
     */
    given_name?: string;
    /**
     * Middle name(s) of the End-User. Note that in some cultures, people can have multiple middle names; all can be present, with the names being separated by space characters. Also note that in some cultures, middle names are not used.
     * @type {string}
     * @memberof ProfileResponse
     */
    middle_name?: string;
    /**
     * Casual name of the End-User that may or may not be the same as the given_name. For instance, a nickname value of Mike might be returned alongside a given_name value of Michael.
     * @type {string}
     * @memberof ProfileResponse
     */
    nickname?: string;
    /**
     * Shorthand name by which the End-User wishes to be referred to by the Provider, such as janedoe or j.doe. This value MAY be any valid JSON string including special characters such as @, /, or whitespace. The Provider MUST NOT rely upon this value being unique.
     * @type {string}
     * @memberof ProfileResponse
     */
    preferred_username?: string;
    /**
     * URL of the End-User\'s profile page. The contents of this Web page SHOULD be about the End-User.
     * @type {string}
     * @memberof ProfileResponse
     */
    profile?: string;
    /**
     * URL of the End-User\'s profile picture. This URL MUST refer to an image file (for example, a PNG, JPEG, or GIF image file), rather than to a Web page containing an image. Note that this URL SHOULD specifically reference a profile photo of the End-User suitable for displaying when describing the End-User, rather than an arbitrary photo taken by the End-User.
     * @type {string}
     * @memberof ProfileResponse
     */
    picture?: string;
    /**
     * URL of the End-User\'s Web page or blog. This Web page SHOULD contain information published by the End-User or an organization that the End-User is affiliated with.
     * @type {string}
     * @memberof ProfileResponse
     */
    website?: string;
    /**
     * End-User\'s gender. Values defined by this specification are female and male. Other values MAY be used when neither of the defined values are applicable.
     * @type {string}
     * @memberof ProfileResponse
     */
    gender?: string;
    /**
     * End-User\'s birthday, represented as an ISO 8601:2004 [ISO8601‑2004] YYYY-MM-DD format. The year MAY be 0000, indicating that it is omitted. To represent only the year, YYYY format is allowed. Note that depending on the underlying platform\'s date related function, providing just year can result in varying month and day, so the implementers need to take this factor into account to correctly process the dates.
     * @type {string}
     * @memberof ProfileResponse
     */
    birthdate?: string;
    /**
     * String from zoneinfo [zoneinfo] time zone database representing the End-User\'s time zone. For example, Europe/Paris or America/Los_Angeles.
     * @type {string}
     * @memberof ProfileResponse
     */
    zoneinfo?: string;
    /**
     * End-User\'s locale.
     * @type {string}
     * @memberof ProfileResponse
     */
    locale?: string;
    /**
     * Identifier for the End-User at the Issuer.
     * @type {string}
     * @memberof ProfileResponse
     */
    sub?: string;
    /**
     * Time the End-User\'s information was last updated. Its value is a JSON number representing the number of seconds from 1970-01-01T0:0:0Z as measured in UTC until the date/time.
     * @type {number}
     * @memberof ProfileResponse
     */
    updated_at?: number;
}
/**
 * 
 * @export
 * @interface ProfileResponseAllOf
 */
export interface ProfileResponseAllOf {
    /**
     * Identifier for the End-User at the Issuer.
     * @type {string}
     * @memberof ProfileResponseAllOf
     */
    sub?: string;
    /**
     * Time the End-User\'s information was last updated. Its value is a JSON number representing the number of seconds from 1970-01-01T0:0:0Z as measured in UTC until the date/time.
     * @type {number}
     * @memberof ProfileResponseAllOf
     */
    updated_at?: number;
}

/**
 * ConnectProfileApi - axios parameter creator
 * @export
 */
export const ConnectProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Register user\'s address based on the provided bearer token
         * @param {AddressPayload} addressPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAddress: async (addressPayload: AddressPayload, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressPayload' is not null or undefined
            assertParamExists('createAddress', 'addressPayload', addressPayload)
            const localVarPath = `/users/me/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a user\'s profile based on the provided bearer token
         * @param {ProfileData} profileData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfile: async (profileData: ProfileData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileData' is not null or undefined
            assertParamExists('createProfile', 'profileData', profileData)
            const localVarPath = `/users/me/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profileData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all user\'s addresses based on the provided bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddresses: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a user\'s profile based on the provided bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark a user\'s address as primary
         * @param {string} id the Address ID identifier of the requested Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markUserAddressAsPrimary: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('markUserAddressAsPrimary', 'id', id)
            const localVarPath = `/users/me/addresses/{id}/primary`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user\'s profile based on the provided bearer token
         * @param {ProfileData} profileData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProfile: async (profileData: ProfileData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileData' is not null or undefined
            assertParamExists('patchProfile', 'profileData', profileData)
            const localVarPath = `/users/me/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profileData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectProfileApi - functional programming interface
 * @export
 */
export const ConnectProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * Register user\'s address based on the provided bearer token
         * @param {AddressPayload} addressPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAddress(addressPayload: AddressPayload, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAddress(addressPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register a user\'s profile based on the provided bearer token
         * @param {ProfileData} profileData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProfile(profileData: ProfileData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProfile(profileData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all user\'s addresses based on the provided bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddresses(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AddressResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddresses(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a user\'s profile based on the provided bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfile(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfile(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mark a user\'s address as primary
         * @param {string} id the Address ID identifier of the requested Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markUserAddressAsPrimary(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markUserAddressAsPrimary(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a user\'s profile based on the provided bearer token
         * @param {ProfileData} profileData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchProfile(profileData: ProfileData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchProfile(profileData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConnectProfileApi - factory interface
 * @export
 */
export const ConnectProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectProfileApiFp(configuration)
    return {
        /**
         * Register user\'s address based on the provided bearer token
         * @param {AddressPayload} addressPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAddress(addressPayload: AddressPayload, options?: any): AxiosPromise<AddressResponse> {
            return localVarFp.createAddress(addressPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Register a user\'s profile based on the provided bearer token
         * @param {ProfileData} profileData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfile(profileData: ProfileData, options?: any): AxiosPromise<ProfileResponse> {
            return localVarFp.createProfile(profileData, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all user\'s addresses based on the provided bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddresses(options?: any): AxiosPromise<Array<AddressResponse>> {
            return localVarFp.getAddresses(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a user\'s profile based on the provided bearer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile(options?: any): AxiosPromise<ProfileResponse> {
            return localVarFp.getProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * Mark a user\'s address as primary
         * @param {string} id the Address ID identifier of the requested Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markUserAddressAsPrimary(id: string, options?: any): AxiosPromise<AddressResponse> {
            return localVarFp.markUserAddressAsPrimary(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a user\'s profile based on the provided bearer token
         * @param {ProfileData} profileData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProfile(profileData: ProfileData, options?: any): AxiosPromise<ProfileResponse> {
            return localVarFp.patchProfile(profileData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConnectProfileApi - object-oriented interface
 * @export
 * @class ConnectProfileApi
 * @extends {BaseAPI}
 */
export class ConnectProfileApi extends BaseAPI {
    /**
     * Register user\'s address based on the provided bearer token
     * @param {AddressPayload} addressPayload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectProfileApi
     */
    public createAddress(addressPayload: AddressPayload, options?: any) {
        return ConnectProfileApiFp(this.configuration).createAddress(addressPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register a user\'s profile based on the provided bearer token
     * @param {ProfileData} profileData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectProfileApi
     */
    public createProfile(profileData: ProfileData, options?: any) {
        return ConnectProfileApiFp(this.configuration).createProfile(profileData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all user\'s addresses based on the provided bearer token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectProfileApi
     */
    public getAddresses(options?: any) {
        return ConnectProfileApiFp(this.configuration).getAddresses(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a user\'s profile based on the provided bearer token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectProfileApi
     */
    public getProfile(options?: any) {
        return ConnectProfileApiFp(this.configuration).getProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark a user\'s address as primary
     * @param {string} id the Address ID identifier of the requested Address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectProfileApi
     */
    public markUserAddressAsPrimary(id: string, options?: any) {
        return ConnectProfileApiFp(this.configuration).markUserAddressAsPrimary(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a user\'s profile based on the provided bearer token
     * @param {ProfileData} profileData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectProfileApi
     */
    public patchProfile(profileData: ProfileData, options?: any) {
        return ConnectProfileApiFp(this.configuration).patchProfile(profileData, options).then((request) => request(this.axios, this.basePath));
    }
}


